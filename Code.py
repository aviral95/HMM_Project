import re
import math
from math import log

obs=raw_input('Enter the sequence:')
obs=re.findall("[A-Z]+",obs)
obs=reduce(lambda i,j:i+j,obs)
states=['N','C']

start_p={"C":0.5,"N":0.5}

trans_p={'C':{'C':log(0.708818492663),'N':log(0.291181507337)},'N':{'C':log(0.00124496070874),'N':log(0.998755039291)}}

emit_p={'N':{'A':log(0.07274739525),'C':log(0.018304828),
             'D':log(0.055531785),  'E':log(0.069877187),
             'F':log(0.018699099),  'G':log(0.054335488),
             'H':log(0.055214248),  'I':log(0.021390933),
             'K':log(0.08839315525),'L':log(0.026880809),
             'M':log(0.036653565),  'N':log(0.072021945),
             'P':log(0.02748489925),'Q':log(0.087152848),
             'R':log(0.08282430025),'S':log(0.094081541),
             'T':log(0.061130806),  'V':log(0.030218048),
             'W':log(0.015131357),  'Y':log(0.021925765)},

#### Trial probabilities from sample proteins and cores.
#        'N':{'P': log(0.12311178247734139), 'S': log(0.1095166163141994), 'D': log(0.08685800604229607), 'A': log(0.0823262839879154),
 #           'R': log(0.08006042296072508), 'T': log(0.06722054380664652), 'G': log(0.0581570996978852), 'K': log(0.04984894259818731),
   #          'V': log(0.0445619335347432),
    #         'N': log(0.03927492447129909), 'L': log(0.0377643504531722), 'Y': log(0.0256797583081571), 'Q': log(0.02416918429003021),
     #        'M': log(0.021148036253776436),
      #       'I': log(0.019637462235649546),'H': log(0.017371601208459216), 'F': log(0.015861027190332326), 'C': log(0.00906344410876133),
       #      'W': log(0.0075528700906344415)},


        'C':{'A':log(0.063631691),'C':log(0.006309705),
             'D':log(0.041325898),'E':log(0.074220578),
             'F':log(0.016431523),'G':log(0.083689366),
             'H':log(0.021413025),'I':log(0.013638164),
             'K':log(0.082934151),'L':log(0.036275237),
             'M':log(0.025146217),'N':log(0.029504778),
             'P':log(0.151254274),'Q':log(0.059750992),
             'R':log(0.081159013),'S':log(0.090731657),
             'T':log(0.061130806),'V':log(0.026504022),
             'W':log(0.017442693),'Y':log(0.016863931)},


        #'C':{'P': log(0.12706299911268856), 'S': log(0.10842945874001775), 'G': log(0.10576752440106478), 'A' : log(0.09813664596273292),
         #    'E': log(0.08198757763975155),
          #   'R': log(0.07879325643300798),
          #   'K': log(0.07808340727595386),'L': log(0.06441881100266193), 'T': log(0.06157941437444543), 'Q': log(0.042413487133984025),
          #   'D': log(0.03939662821650399),
           #  'V': log(0.0321206743566992),
           #  'N': log(0.021472937000887312), 'I': log(0.014729370008873114), 'F': log(0.01188997338065661),'M': log(0.01082519964507542),
            # 'Y': log(0.009228039041703637),
             #'H': log(0.00816326530612245),
             #'W': log(0.004081632653061225), 'C': log(0.001419698314108252)},

        }


 

def viterbi(obs, states, start_p, trans_p, emit_p):
    V = [{}]
    path = {}
 
    for y in states:
        V[0][y] = start_p[y] + emit_p[y][obs[0]]
        path[y] = [y]

    for t in range(1, len(obs)):
        V.append({})
        newpath = {}
 
        for y in states:
            (prob, state) = max((V[t-1][y0] + trans_p[y0][y] + emit_p[y][obs[t]], y0) for y0 in states)
            V[t][y] = prob
            newpath[y] = path[state] + [y]
 
        path = newpath
        
    n=0
    if len(obs)!=1:
        n=t
    (prob, state)= max((V[n][y],y) for y in states)
    output=''.join(path[state])
    return (prob,output)

print viterbi(obs, states, start_p, trans_p, emit_p)[1]

        
            
